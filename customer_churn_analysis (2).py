# -*- coding: utf-8 -*-
"""Customer Churn Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1l7g4k19uVgV2I2j5yTteozJyfCUcUT6c

**Customer Churn Analysis**

PROJECT NAME : **Customer
Churn
Analysis**

Project Prepared By:   Alaska

**Problem Statement : **
Analyze customer churn data to identify key factors that contribute to customers leaving the service and to understand the characteristics of churned customers. The goal is to gain insights that can inform strategies to reduce churn and improve customer retention.
"""

# Importing Data
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

df = pd.read_csv('Customer Churn.csv')
df.head()

df.info()

"""#replacing blanks with 0 as tenure is 0 and no total charges are recorded"""

#Data Cleaning and Inspection
df["TotalCharges"] = df["TotalCharges"].replace(" ","0")
df["TotalCharges"] = df["TotalCharges"].astype("float")

df.info()

df.isnull().sum().sum()

df.describe()

df["customerID"].duplicated().sum()

#Converting 'SeniorCitizen' to Categorical
#This code converts the numerical values in the 'SeniorCitizen' column to 'yes' and 'no' for better readability.

def conv(value):
    if value == 1:
        return "yes"
    else:
        return "no"

df['SeniorCitizen'] = df["SeniorCitizen"].apply(conv)

"""**converted 0 and 1 values of senior citizen to yes/no to make it easier to understand**

1: What is the insight I get from this graph? Ans= From this graph, we can see the total number of customers who have churned ('Yes') and who have not churned ('No'). This provides a basic understanding of the class imbalance in the dataset, showing that there are significantly more customers who have not churned (5174) than those who have (1869).

2: Why is this graph used only instead of other? Ans = This count plot is used to visualize the distribution of churned and non-churned customers. It helps to quickly see the absolute number of customers in each category and understand the overall churn rate in terms of raw counts.
"""

#Visualizing the Distribution of Churn
#This code generates a count plot to show the number of customers who have churned and those who have not.
ax = sns.countplot(x = 'Churn', data = df)

ax.bar_label(ax.containers[0])
plt.title("Count of Customers by Churn")
plt.show()

"""1: What is the insight I get from this graph? Ans= From the given pie chart, we can conclude that 26.54% of our customers have churned out.

2: Why is this graph used only instead of other? Ans = This pie chart is used to visualize the proportion of churned and non-churned customers as a percentage of the total customer base. It provides a clear and simple way to show the overall churn rate.
"""

# Visualizing the Percentage of Churned Customers
#This code generates a pie chart to show the proportion of customers who have churned.

plt.figure(figsize = (3,4))
gb = df.groupby("Churn").agg({'Churn':"count"})
plt.pie(gb['Churn'], labels = gb.index, autopct = "%1.2f%%")
plt.title("Percentage of Churned Customeres", fontsize = 10)
plt.show()

"""**from the given pie chart we can conclude that 26.54% of our customers have churned out.
not let's explore the reason behind it**

1: What is the insight I get from this graph?
Ans= This graph shows that the number of churned customers is roughly similar for both genders.

2: Why is this graph used only instead of other?
Ans =A count plot is used here because 'gender' is a categorical variable, and we want to see the count of customers in each category (male and female) and how those counts are distributed with respect to churn.
"""

#Visualizing Churn by Gender
#This code generates a count plot to show the number of churned and non-churned customers for each gender.

plt.figure(figsize = (3,3))
sns.countplot(x = "gender", data = df, hue = "Churn")
plt.title("Churn by Gender")
plt.show()

"""
1: What is the insight I get from this graph?
Ans= This graph shows that the majority of customers (5901) are not senior citizens, while a smaller number (1142) are senior citizens.

2: Why is this graph used only instead of other?
Ans= A count plot is used to visualize the distribution of a categorical variable ('SeniorCitizen'). It clearly shows the number of observations in each category, which is suitable for understanding the composition of the customer base by senior citizen status."""

#Visualizing Customer Distribution by Senior Citizen
#This code generates a count plot to show the number of customers who are senior citizens and those who are not.

plt.figure(figsize = (4,4))
ax = sns.countplot(x = "SeniorCitizen", data = df)
ax.bar_label(ax.containers[0])
plt.title("Count of Customers by Senior Citizen")
plt.show()

"""1: What is the insight I get from this graph?
Ans= This graph reveals that a higher percentage of senior citizens (41.7%) have churned compared to non-senior citizens (23.6%). This suggests that senior citizenship could be a factor influencing churn.

2: Why is this graph used only instead of other?
Ans = A stacked bar chart is used to compare the proportion of churn within each category of a categorical variable ('SeniorCitizen'). It clearly shows the percentage breakdown of churned and non-churned customers for both groups, making it easy to see the difference in churn rates.
"""

#Visualizing Churn Percentage by Senior Citizen
#This code generates a stacked bar chart to show the percentage of churned and non-churned customers for senior citizens and non-senior citizens.



total_counts = df.groupby('SeniorCitizen')['Churn'].value_counts(normalize=True).unstack() * 100

# Plot
fig, ax = plt.subplots(figsize=(4, 4))  # Adjust figsize for better visualization

# Plot the bars
total_counts.plot(kind='bar', stacked=True, ax=ax, color=['#1f77b4', '#ff7f0e'])  # Customize colors if desired

# Add percentage labels on the bars
for p in ax.patches:
    width, height = p.get_width(), p.get_height()
    x, y = p.get_xy()
    ax.text(x + width / 2, y + height / 2, f'{height:.1f}%', ha='center', va='center')

plt.title('Churn by Senior Citizen (Stacked Bar Chart)')
plt.xlabel('SeniorCitizen')
plt.ylabel('Percentage (%)')
plt.xticks(rotation=0)
plt.legend(title='Churn', bbox_to_anchor = (0.9,0.9))  # Customize legend location

plt.show()

"""#comparative a greater pecentage of people in senior citizen category have churned

1: What is the insight I get from this graph?

Ans= This graph indicates that customers with shorter tenure (around 1-2 months) have a much higher likelihood of churning, while customers with longer tenure are more likely to remain with the service.

2: Why is this graph used only instead of other?

Ans = A histogram is used to visualize the distribution of a numerical variable ('tenure') and how its distribution differs based on a categorical variable ('Churn'). It's effective for showing the frequency of different tenure values for both churned and non-churned groups.
"""

#Visualizing Churn by Tenure
#This code generates a histogram to show the distribution of customer tenure and how it relates to churn.

plt.figure(figsize = (9,4))
sns.histplot(x = "tenure", data = df, bins = 72, hue = "Churn")
plt.show()

"""#people who have used our services for a long time have stayed and people who have used our sevices
#1 or 2 months  have churned
"""



"""1: What is the insight I get from this graph?
Ans: This graph clearly shows that customers with month-to-month contracts have a significantly higher churn rate (1655 churned customers) compared to those with one-year (166) or two-year (48) contracts.

2: Why is this graph used only instead of other?
Ans = A count plot is used to visualize the distribution of a categorical variable ('Contract') and how churn is distributed within each category. It effectively shows the number of churned and non-churned customers for each contract type.
"""

#Visualizing Churn by Contract Type
#This code generates a count plot to show the number of churned and non-churned customers for each contract type.
plt.figure(figsize = (4,4))
ax = sns.countplot(x = "Contract", data = df, hue = "Churn")
ax.bar_label(ax.containers[0])
plt.title("Count of Customers by Contract")
plt.show()

#people who have month to month contract are likely to churn then from those who have 1 or 2 years or contract.

df.columns.values

"""1: What is the insight I get from this graph? Ans= The majority of customers who do not churn tend to have services like PhoneService, InternetService (particularly DSL), and OnlineSecurity enabled. For services like OnlineBackup, TechSupport, and StreamingTV, churn rates are noticeably higher when these services are not used or are unavailable.

2: Why is this graph used only instead of other? Ans = These count plots are used to visualize the distribution of categorical variables (the different services) and how churn is distributed within each category. They effectively show the number of churned and non-churned customers for each service option.
"""

#Visualizing Churn by Service Types
#This code generates count plots to show the distribution of churn across various customer services

columns = ['PhoneService', 'MultipleLines', 'InternetService', 'OnlineSecurity',
           'OnlineBackup', 'DeviceProtection', 'TechSupport', 'StreamingTV', 'StreamingMovies']

# Number of columns for the subplot grid (you can change this)
n_cols = 3
n_rows = (len(columns) + n_cols - 1) // n_cols  # Calculate number of rows needed

# Create subplots
fig, axes = plt.subplots(n_rows, n_cols, figsize=(15, n_rows * 4))  # Adjust figsize as needed

# Flatten the axes array for easy iteration (handles both 1D and 2D arrays)
axes = axes.flatten()

# Iterate over columns and plot count plots
for i, col in enumerate(columns):
    sns.countplot(x=col, data=df, ax=axes[i], hue = df["Churn"])
    axes[i].set_title(f'Count Plot of {col}')
    axes[i].set_xlabel(col)
    axes[i].set_ylabel('Count')

# Remove empty subplots (if any)
for j in range(i + 1, len(axes)):
    fig.delaxes(axes[j])

plt.tight_layout()
plt.show()

"""**The majority of customers who do not churn tend to have services like PhoneService, InternetService (particularly DSL), and OnlineSecurity enabled. For services like OnlineBackup, TechSupport, and StreamingTV, churn rates are noticeably higher when these services are not used or are unavailable.**

1: What is the insight I get from this graph? Ans= This graph suggests that customers using Electronic Check as a payment method have a higher propensity to churn (1071 churned customers) compared to those using other payment methods like Mailed Check (308), Bank Transfer (automatic) (258), or Credit Card (automatic) (232).

2: Why is this graph used only instead of other? Ans = A count plot is used to visualize the distribution of a categorical variable ('PaymentMethod') and how churn is distributed within each category. It effectively shows the number of churned and non-churned customers for each payment method.
"""

#Visualizing Churn by Payment Method
#This code generates a count plot to show the number of churned and non-churned customers for each payment method.

plt.figure(figsize = (6,4))
ax = sns.countplot(x = "PaymentMethod", data = df, hue = "Churn")
ax.bar_label(ax.containers[0])
ax.bar_label(ax.containers[1])
plt.title("Churned Customers by Payment Method")
plt.xticks(rotation = 45)
plt.show()

"""#customer is likely to churn when he is using electronic check as a payment method.

# Task
Perform logistic regression and feature engineering to segment churners and identify key risk factors.

## Feature engineering


Create dummy variables for categorical features to prepare the data for logistic regression.

**Reasoning**:
Create dummy variables for the categorical features and drop the original columns to prepare the data for logistic regression.
"""

### Feature Engineering: Creating Dummy Variables

categorical_cols = df.select_dtypes(include='object').columns
df = pd.get_dummies(df, columns=categorical_cols, drop_first=True)
df.head()

"""**Reasoning**:
The dataframe 'df' was not found. Reload the data and then create dummy variables for the categorical features and drop the original columns to prepare the data for logistic regression.


"""

### Data Loading and Preprocessing
#This code loads the customer churn data, cleans the 'TotalCharges' column, converts 'SeniorCitizen' to a categorical type, and creates dummy variables for other categorical features.

df = pd.read_csv('Customer Churn.csv')
df["TotalCharges"] = df["TotalCharges"].replace(" ","0")
df["TotalCharges"] = df["TotalCharges"].astype("float")
def conv(value):
    if value == 1:
        return "yes"
    else:
        return "no"

df['SeniorCitizen'] = df["SeniorCitizen"].apply(conv)
categorical_cols = df.select_dtypes(include='object').columns
df = pd.get_dummies(df, columns=categorical_cols, drop_first=True)
df.head()

#Model Training
#This code trains a logistic regression model on the training data.
#from sklearn.linear_model import LogisticRegression

model = LogisticRegression(max_iter=200)
model.fit(X_train, y_train)

"""## Model evaluation


Evaluate the performance of the logistic regression model using appropriate metrics.

**Reasoning**:
Evaluate the performance of the trained logistic regression model using accuracy, precision, recall, F1-score, and a confusion matrix.

1: What is the insight I get from this graph? Ans= From this confusion matrix, we can see how well the logistic regression model performed in classifying churned and non-churned customers. It correctly identified 990 non-churned customers (True Negatives) and 118 churned customers (True Positives). However, it incorrectly predicted 255 churned customers as not churning (False Negatives), indicating it missed a significant number of actual churners, and incorrectly predicted 46 non-churned customers as churning (False Positives).

2: Why is this graph used only instead of other? Ans= A confusion matrix is used because it provides a detailed breakdown of the model's predictions, showing not just overall accuracy but also the types of errors (false positives and false negatives). This is crucial for understanding the model's performance, especially in datasets with imbalanced classes like this one, where simply looking at accuracy can be misleading.
"""

#Model Evaluation
#This code evaluates the performance of the logistic regression model using accuracy, precision, recall, F1-score, and a confusion matrix.

from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, confusion_matrix
import seaborn as sns
import matplotlib.pyplot as plt

y_pred = model.predict(X_test_scaled)

accuracy = accuracy_score(y_test, y_pred)
precision = precision_score(y_test, y_pred)
recall = recall_score(y_test, y_pred)
f1 = f1_score(y_test, y_pred)
conf_matrix = confusion_matrix(y_test, y_pred)

print(f'Accuracy: {accuracy:.4f}')
print(f'Precision: {precision:.4f}')
print(f'Recall: {recall:.4f}')
print(f'F1-score: {f1:.4f}')

plt.figure(figsize=(6, 4))
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=['No Churn', 'Churn'], yticklabels=['No Churn', 'Churn'])
plt.xlabel('Predicted Label')
plt.ylabel('True Label')
plt.title('Confusion Matrix')
plt.show()

"""## Identify key risk factors


Analyze the coefficients of the logistic regression model to identify the key risk factors for churn.

**Reasoning**:
Create a pandas Series of the model coefficients, sort them by absolute value, and display the result to identify key risk factors.
"""

#Identifying Key Risk Factors
#This code analyzes the coefficients of the logistic regression model to identify the most influential features for churn.

coefficients = pd.Series(model.coef_[0], index=X_train.columns)
sorted_coefficients = coefficients.abs().sort_values(ascending=False)
print("Top features influencing churn based on absolute coefficient values:")
print(coefficients[sorted_coefficients.index])

"""## Segment churners

Based on the key risk factors, segment the churned customers to understand their characteristics.

**Reasoning**:
Filter the DataFrame to include only churned customers and then analyze the distributions of key risk factors among these churned customers using descriptive statistics and value counts. This will provide insights into the characteristics of the churned segment based on the identified risk factors.
"""

#Analyzing Churned Customer Characteristics
#This code filters the data for churned customers and analyzes the distributions of key risk factors within this segment.

churned_customers_df = df[df['Churn_Yes'] == True].copy()

numerical_risk_factors = ['tenure', 'MonthlyCharges', 'TotalCharges']
print("Descriptive statistics for numerical risk factors among churned customers:")
display(churned_customers_df[numerical_risk_factors].describe())

categorical_risk_factors = ['InternetService_Fiber optic', 'PaymentMethod_Electronic check', 'OnlineSecurity_Yes', 'TechSupport_Yes', 'Contract_Two year']
print("\nValue counts for categorical risk factors among churned customers:")
for col in categorical_risk_factors:
    print(f"\n{col}:")
    display(churned_customers_df[col].value_counts())

"""**Reasoning**:
Visualize the distribution of key risk factors among churned customers to gain a better understanding of their characteristics. Histograms will be used for numerical features and bar plots for categorical features.

1: What is the insight I get from this graph? Ans= Churned customers often have short tenures, higher monthly charges, and lower total charges. They are more likely to have Fiber optic internet and use electronic checks, and less likely to have online security or tech support.

2: Why is this graph used only instead of other? Ans= Histograms effectively show the distribution of numerical data (tenure, charges), highlighting common value ranges among churners. Count plots are used for categorical data (services, payment method) to clearly show the number of churned customers in each category, making it easy to compare proportions.
"""

#Visualizing Churned Customer Characteristics
#This code visualizes the distribution of key risk factors among churned customers to understand their characteristics.

numerical_risk_factors = ['tenure', 'MonthlyCharges', 'TotalCharges']
plt.figure(figsize=(15, 5))
for i, col in enumerate(numerical_risk_factors):
    plt.subplot(1, 3, i + 1)
    sns.histplot(data=churned_customers_df, x=col, kde=True)
    plt.title(f'Distribution of {col} among Churned Customers')
plt.tight_layout()
plt.show()

categorical_risk_factors = ['InternetService_Fiber optic', 'PaymentMethod_Electronic check', 'OnlineSecurity_Yes', 'TechSupport_Yes', 'Contract_Two year']
plt.figure(figsize=(15, 10))
for i, col in enumerate(categorical_risk_factors):
    plt.subplot(2, 3, i + 1)
    sns.countplot(data=churned_customers_df, x=col)
    plt.title(f'Count of {col} among Churned Customers')
plt.tight_layout()
plt.show()

"""## Visualize results


Visualize the key risk factors and churner segments to present the findings.

**Reasoning**:
Create visualizations to show the relationship between the key risk factors and churn, using histograms for numerical features and count plots for categorical features, differentiating between churned and non-churned customers.

1: What is the insight I get from this graph? Ans= These graphs show that churn is higher among customers with short tenure, high monthly charges, Fiber optic internet, electronic check payment, and those without online security or tech support. Customers with longer tenures and two-year contracts are less likely to churn.

2: Why is this graph used only instead of other? Ans= Histograms and count plots with the 'hue' parameter for 'Churn_Yes' are used to directly compare the distributions and counts of churned versus non-churned customers across numerical and categorical features, making it easy to see which factors are associated with higher or lower churn rates.
"""

###Visualizing Key Risk Factors vs. Churn
##This code visualizes the relationship between key risk factors and customer churn across the entire dataset.

# Visualize numerical risk factors vs. Churn
numerical_risk_factors = ['tenure', 'MonthlyCharges', 'TotalCharges']
plt.figure(figsize=(15, 5))
for i, col in enumerate(numerical_risk_factors):
    plt.subplot(1, 3, i + 1)
    sns.histplot(data=df, x=col, hue='Churn_Yes', kde=True, palette='viridis')
    plt.title(f'Distribution of {col} by Churn')
plt.tight_layout()
plt.show()

# Visualize categorical risk factors vs. Churn (proportion)
categorical_risk_factors = ['InternetService_Fiber optic', 'PaymentMethod_Electronic check', 'OnlineSecurity_Yes', 'TechSupport_Yes', 'Contract_Two year']
plt.figure(figsize=(15, 10))
for i, col in enumerate(categorical_risk_factors):
    plt.subplot(2, 3, i + 1)
    sns.countplot(data=df, x=col, hue='Churn_Yes', palette='viridis')
    plt.title(f'Churn Proportion by {col}')
    plt.xticks(rotation=0)
plt.tight_layout()
plt.show()